module everyone_is_an_equal_citizen;
create REPUBLIC : republic, VAPODI_TRACE : VAPODI_TRACE_METAMODEL from KINGDOM : kingdom;

-- from references strictly metamodels -> insane if multiple input files of same MM
rule knight2citizen {
 from
  knight : kingdom!Knight
 to
  citizen : republic!Citizen (
   name <- knight.name
  )
 do {
  if(knight.name = 'kuno')
   -- [VAPODI] warning: ATL instruction below is not handled by VAPODI and has been ignored for its analysis
   citizen.name <- 'alter Schwede';
  'warning: actionless placeholder for instruction of type CfsPush'.println();
  thisModule.CFS_pop_multiple(1);
 }
}

rule dragon2citizen {
 from
  dragon : kingdom!Dragon
 to
  citizen : republic!Citizen
 do {
  'warning: actionless placeholder for instruction of type CfsPush'.println();
  thisModule.CFS_pop_multiple(1);
 }
}

helper context VAPODI_TRACE_METAMODEL!DynamicEntity def: equals(other : VAPODI_TRACE_METAMODEL!DynamicEntity) : Boolean =
 self.concern = other.concern and self.object = other.object and self.attributeName = other.attributeName;

helper def: fail_softly : Boolean =
 true;

helper def: trace_collection : VAPODI_TRACE_METAMODEL!TraceCollection =
 VAPODI_TRACE_METAMODEL!TraceCollection.newInstance();

rule add_trace_link_internal(target : VAPODI_TRACE_METAMODEL!DynamicEntity) {
 using
 {
  aDependency : VAPODI_TRACE_METAMODEL!DynamicEntity = VAPODI_TRACE_METAMODEL!DynamicEntity.newInstance();
  aDependencyCopy : VAPODI_TRACE_METAMODEL!DynamicEntity = VAPODI_TRACE_METAMODEL!DynamicEntity.newInstance();
  dependencies : Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity) = Sequence {};
 }
 to
  link : VAPODI_TRACE_METAMODEL!DynamicEntity
 do {
  link.destination <- target; -- make a real copy
  -- make a real copy
  for(aDependency in thisModule.CFS.flatten()) {
   aDependencyCopy = VAPODI_TRACE_METAMODEL!DynamicEntity.newInstance();
   aDependencyCopy.attributeName <- aDependency.attributeName;
   aDependencyCopy.concern <- aDependency.concern;
   aDependencyCopy.semantics <- aDependency.semantics;
   aDependencyCopy.universe <- aDependency.universe;
   aDependencyCopy.object <- aDependency.object;
   dependencies <- dependencies.including(aDependencyCopy);
  }
  link.source <- dependencies;
  thisModule.trace_collection <- thisModule.trace_collection.including(link);
 }
}

rule add_trace_link_to_model_variable(target_object : ecore!EObject, semantics : VAPODI_TRACE_METAMODEL!TraceType, universe : VAPODI_TRACE_METAMODEL!UniverseType) {
 to
  target : VAPODI_TRACE_METAMODEL!DynamicEntity (
   concern <- #OBJECT,
   semantics <- semantics,
   universe <- universe
  )
 do {
  target.object <- target_object;
  thisModule.add_trace_link_internal(target);
 }
}

rule add_trace_link_to_model_attribute_variable(target_object : ecore!EObject, attribute : String, semantics : VAPODI_TRACE_METAMODEL!TraceType, universe : VAPODI_TRACE_METAMODEL!UniverseType) {
 to
  target : VAPODI_TRACE_METAMODEL!DynamicEntity (
   concern <- #ATTRIBUTE,
   semantics <- semantics,
   universe <- universe,
   attributeName <- attribute
  )
 do {
  target.object <- target_object;
  thisModule.add_trace_link_internal(target);
 }
}

helper def: CFS : Sequence(Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) =
 Sequence {};

helper def: cfs_flat_copy() : Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity) =
 thisModule.CFS.flatten();

helper def: ST_prim_variables : Map(String, -- name of variable
Sequence(-- account for shadowed names 
Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity))) =
 Map {};

rule ST_put_prim_variable(variable_name : String) {
 using
 {
  seq_for_this_name : Sequence(Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) = 0;
 }
 do {
  seq_for_this_name <- thisModule.ST_prim_variables.get(variable_name);
  if(seq_for_this_name.oclIsUndefined())
   seq_for_this_name <- Sequence {};
  seq_for_this_name <- seq_for_this_name.including(thisModule.cfs_flat_copy());
  thisModule.ST_prim_variables <- thisModule.ST_prim_variables.including(variable_name, seq_for_this_name);
 }
}

rule ST_drop_prim_variable(variable_name : String) {
 using
 {
  seq_for_this_name : Sequence(Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) = 0;
 }
 do {
  seq_for_this_name <- thisModule.ST_prim_variables.get(variable_name);
  thisModule.assert(not seq_for_this_name.oclIsUndefined(), 'Can\'t drop ST_prim_variables entry for variable \"' + variable_name + '\"');
  seq_for_this_name <- seq_for_this_name.subSequence(1, seq_for_this_name.size() - 1);
  thisModule.ST_prim_variables <- thisModule.ST_prim_variables.including(variable_name, seq_for_this_name);
 }
}

rule ST_push_deps_of_prim_variable(variable_name : String) {
 using
 {
  seq_for_this_name : Sequence(Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) = 0;
 }
 do {
  seq_for_this_name <- thisModule.ST_prim_variables.get(variable_name);
  thisModule.assert(not seq_for_this_name.oclIsUndefined(), 'Can\'t find ST_prim_variables entry for variable \"' + variable_name + '\"');
  thisModule.CFS_push_seq(seq_for_this_name.last());
 }
}

helper def: ST_model_attribute_variables : Map(ecore!EObject, -- all together: object -> attribute -> seq. of deps
Map(String, Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity))) =
 Map {};

rule ST_put_model_attribute_variable(variable : ecore!EObject, attribute : String) {
 using
 {
  attributeMap : Map(String, Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) = Map {};
 }
 do {
  -- identify or if not present create entry for variable object
  -- identify or if not present create entry for variable object
  attributeMap <- thisModule.ST_model_attribute_variables.get(variable);
  if(attributeMap.oclIsUndefined()) {
   attributeMap <- Map {};
   thisModule.ST_model_attribute_variables <- thisModule.ST_model_attribute_variables.including(attributeMap);
  } -- do we have to identify 
  -- attributeEntry <- attributeMap.get(attribute);
  -- No, the entry is clobbered if present or newly created if not - we don't have to care for this
  -- do we have to identify 
  -- attributeEntry <- attributeMap.get(attribute);
  -- No, the entry is clobbered if present or newly created if not - we don't have to care for this
  -- do we have to identify 
  -- attributeEntry <- attributeMap.get(attribute);
  -- No, the entry is clobbered if present or newly created if not - we don't have to care for this
  attributeMap <- attributeMap.including(attribute, thisModule.cfs_flat_copy());
 }
}

rule ST_drop_model_attribute_variables(variable_to_drop : ecore!EObject) {
 using
 {
  deps_of_model_var : Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity) = Sequence {};
  cleaned_ST_model_attribute_variables : Map(ecore!EObject, Map(String, Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity))) = Map {};
  variable : ecore!EObject = 0;
 }
 do {
  deps_of_model_var <- thisModule.ST_model_variables.get(variable);
  for(variable in thisModule.ST_model_variables.getKeys()) {
   if(variable <> variable_to_drop)
    cleaned_ST_model_attribute_variables <- cleaned_ST_model_attribute_variables.including(variable, thisModule.ST_model_variables.get(variable));
   
  }
  thisModule.ST_model_variables <- cleaned_ST_model_attribute_variables;
 }
}

rule CFS_push_deps_of_model_attribute_variable(object : Ecore!EObject) {
 using
 {
  deps_of_model_var : Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity) = Sequence {};
 }
 do {
  deps_of_model_var <- thisModule.ST_model_variables.get(object);
  thisModule.CFS_push_seq(deps_of_model_var);
 }
}

rule CFS_push_model_attribute_variable(object : Ecore!EObject, attribute : String, semantics : VAPODI_TRACE_METAMODEL!TraceType, universe : VAPODI_TRACE_METAMODEL!UniverseType) {
 to
  what : VAPODI_TRACE_METAMODEL!DynamicEntity (
   concern <- #ATTRIBUTE,
   semantics <- semantics,
   universe <- universe,
   attributeName <- attribute
  )
 do {
  what.object <- object;
  thisModule.CFS_push_single(what);
 }
}

helper def: ST_model_variables : Map(ecore!EObject, Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) =
 Map {};

rule ST_put_model_variable(variable : ecore!EObject) {
 do {
  thisModule.ST_model_variables <- thisModule.ST_model_variables.including(variable, thisModule.cfs_flat_copy());
 }
}

rule ST_drop_model_variable(variable_to_drop : ecore!EObject) {
 using
 {
  cleaned_ST_model_variables : Map(ecore!EObject, Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) = Map {};
  drop_counter : Integer = 0;
 }
 do {
  -- life could be so easy:
  --thisModule.ST_model_variables <- thisModule.ST_model_variables.excluding(variable);
  -- workaround idea 1: we clob the value associated with variable to be empty
  -- thisModule.ST_model_variables <- thisModule.ST_model_variables.including(variable, Sequence {} );
  -- yet then we had to rewrite all code accessing this function to account for this special case
  -- now for the ugly solution
  for(variable in thisModule.ST_model_variables.getKeys()) {
   if(variable = variable_to_drop)
    drop_counter <- drop_counter + 1; --'dropped'.println();
    
   else
    cleaned_ST_model_variables <- cleaned_ST_model_variables.including(variable, thisModule.ST_model_variables.get(variable)); --('copy ' + variable.fullName).println();
    
   
  }
  thisModule.assert(drop_counter = 1, 'removed a variable ' + drop_counter.toString() + ' times from ST_model_variables which should have been there exactly once');
  thisModule.ST_model_variables <- cleaned_ST_model_variables; -- 2nd part: ST_model_attribute_variables
  -- 2nd part: ST_model_attribute_variables
  -- 2nd part: ST_model_attribute_variables
  -- 2nd part: ST_model_attribute_variables
  thisModule.ST_drop_model_attribute_variables(variable_to_drop);
 }
}

rule CFS_push_deps_of_model_variable(variable : Ecore!EObject) {
 do {
  thisModule.CFS_push_seq(thisModule.ST_model_variables.get(variable));
 }
}

rule CFS_push_model_variable(object : Ecore!EObject, semantics : VAPODI_TRACE_METAMODEL!TraceType, universe : VAPODI_TRACE_METAMODEL!UniverseType) {
 to
  what : VAPODI_TRACE_METAMODEL!DynamicEntity (
   concern <- #OBJECT,
   semantics <- semantics,
   universe <- universe
  )
 do {
  what.object <- object;
  thisModule.CFS_push_single(what);
 }
}

rule CFS_push_single(what : VAPODI_TRACE_METAMODEL!DynamicEntity) {
 do {
  thisModule.CFS_push_seq(Sequence {what});
 }
}

rule CFS_push_seq(what : Sequence(VAPODI_TRACE_METAMODEL!DynamicEntity)) {
 do {
  thisModule.CFS <- thisModule.CFS.append(what);
 }
}

rule CFS_pop() {
 do {
  thisModule.assert(not thisModule.CFS.isEmpty(), 'Trying to pop from empty Control Flow Stack. ' + '(This is an internal error resulting from wrong composition; ' + 'As a user, you cannnot do much about it)'); -- workaround: as we can't destroy created objects and all existing objects make their way into output file,
  --             so we have them in one place, at least
  -- does not work, as containment references may not span across models (ATL error msg)
  --thisModule.traceCollection.trash <-
  --thisModule.traceCollection.trash.union(thisModule.CFS.last());
  -- workaround: empty subsequence is returned as [], not as an empty sequence
  --             (does not even have collection type operations) 
  -- workaround: as we can't destroy created objects and all existing objects make their way into output file,
  --             so we have them in one place, at least
  -- does not work, as containment references may not span across models (ATL error msg)
  --thisModule.traceCollection.trash <-
  --thisModule.traceCollection.trash.union(thisModule.CFS.last());
  -- workaround: empty subsequence is returned as [], not as an empty sequence
  --             (does not even have collection type operations) 
  if(thisModule.CFS.size() > 1)
   thisModule.CFS <- thisModule.CFS.subSequence(1, thisModule.CFS.asSequence().size() - 1);
  else
   thisModule.CFS <- Sequence {};
  
 }
}

rule CFS_pop_multiple(n : Integer) {
 do {
  thisModule.assert(n >= 0, 'Tried to pop negative number of items from CFS'); -- workaround: recursive emulation of numeric for loop
  -- workaround: recursive emulation of numeric for loop
  if(n > 0) {
   thisModule.CFS_pop();
   thisModule.CFS_pop_multiple(n - 1);
  }
 }
}
