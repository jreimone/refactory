epackage refactoring_specification ; 

// plain Java imports
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EClass; 
import org.eclipse.emf.common.util.EList; 
import org.eclipse.emf.common.util.BasicEList; 
import java.util.List;
import java.util.Set;
import java.util.LinkedHashSet;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.util.EcoreUtil;

//import org.emftext.language.refactoring.refactoring_specification.Variable;
//import org.emftext.language.refactoring.refactoring_specification.Instruction;

// import of other EClasses
import roles.Role;
eclass RefactoringSpecification { 
	getDeclaredVariables ( ) { 
			org.eclipse.emf.common.util.EList < org.emftext.language.refactoring.refactoring_specification.Variable > variables = new org.eclipse.emf.common.util.BasicEList < org.emftext.language.refactoring.refactoring_specification.Variable > ( ) ; 
			org.eclipse.emf.common.util.EList < org.emftext.language.refactoring.refactoring_specification.Instruction > instructions = getInstructions ( ) ; 
			for ( org.emftext.language.refactoring.refactoring_specification.Instruction instruction : instructions ) { 
				if ( instruction instanceof org.emftext.language.refactoring.refactoring_specification.VariableDeclarationCommand ) { 
					org.emftext.language.refactoring.refactoring_specification.Variable var = ( ( org.emftext.language.refactoring.refactoring_specification.VariableDeclarationCommand ) instruction ) .getVariable ( ) ; 
					if ( var != null ) { 
						variables .add ( var ) ; 
					} 
				} 
			} 
			return variables ; 
		} 
	getVariableByName ( ) { 
			EList < Variable > variables = getDeclaredVariables ( ) ; 
			for ( Variable variable : variables ) { 
				if ( variable .getName ( ) .equals ( name ) ) { 
					return variable ; 
				} 
			} 
			return null ; 
		} 
		
	getInstructionsReferencingRole() {
		Set<Instruction> instructions = new LinkedHashSet<Instruction>();
		List<Instruction> usedInstructions = getInstructions();
		for (Instruction instruction : usedInstructions) {
			boolean isReferencingObject = isRoleReferencedByObject(referencedRole, instruction);
			if(isReferencingObject){
				instructions.add(instruction);
			}
			TreeIterator<EObject> iterator = EcoreUtil.getAllContents(instruction, true);
			while (iterator.hasNext()) {
				EObject eObject = (EObject) iterator.next();
				isReferencingObject = isRoleReferencedByObject(referencedRole, eObject);
				if(isReferencingObject){
					instructions.add(instruction);
				}
			}
		}
		return new BasicEList<Instruction>(instructions);
	}
	
	isRoleReferencedByObject() {
		EClass metaclass = eObject.eClass();
		List<EReference> references = metaclass.getEAllReferences();
		for (EReference reference : references) {
			if(!reference.isContainment()){
				EClassifier classifier = reference.getEType();
				if(classifier.isInstance(referencedRole)){
					Object value = eObject.eGet(reference);
					if(value instanceof Role){
						if(((Role) value).equals(referencedRole)){
							return true;
						}
					} else if(value instanceof List<?>){
						for (Role listObject : (List<Role>) value) {
							if(listObject.equals(referencedRole)){
								return true;
							}
						}
					}
				}
			}
		}
		return false;
	}
} 